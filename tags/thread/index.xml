<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Thread on Zput's blog</title><link>http://zput.github.io/tags/thread/</link><description>Recent content in Thread on Zput's blog</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Thu, 04 Jul 2019 19:00:00 +0000</lastBuildDate><atom:link href="http://zput.github.io/tags/thread/index.xml" rel="self" type="application/rss+xml"/><item><title>进程间通讯</title><link>http://zput.github.io/post/_posts/process_communication/</link><pubDate>Thu, 04 Jul 2019 19:00:00 +0000</pubDate><guid>http://zput.github.io/post/_posts/process_communication/</guid><description>including IPC的方式通常有 管道（包括无名管道和命名管道）:PIPE 信号量: 消息队列: 信号量 共享存储: mmap() shm Socket &amp;mdash; Streams: ##including 管道中的无名管道是存放在文件描述符</description></item><item><title>谈谈线程</title><link>http://zput.github.io/post/_posts/thread/</link><pubDate>Thu, 04 Jul 2019 19:00:00 +0000</pubDate><guid>http://zput.github.io/post/_posts/thread/</guid><description>什么是进程？ 从概念上来说：进程是计算机顺序执行的程序的过程，它是系统资源分配的最小单位。从我个人理解来说它类似于一个容器，里面有很多的资源（</description></item><item><title>线程死锁</title><link>http://zput.github.io/post/_posts/lock/</link><pubDate>Fri, 21 Jun 2019 15:00:00 +0000</pubDate><guid>http://zput.github.io/post/_posts/lock/</guid><description>线程死锁 线程死锁 什么是线程死锁，如何解决 产生死锁的条件有四个： 互斥条件：所谓互斥就是进程在某一时间内独占资源。 请求与保持条件：一个进程因请求</description></item><item><title>异步与同步</title><link>http://zput.github.io/post/_posts/%E6%A6%82%E5%BF%B5%E5%8E%9F%E7%90%86%E7%9A%84%E6%80%9D%E8%80%83/synchronous_asynchronous/</link><pubDate>Fri, 21 Jun 2019 15:00:00 +0000</pubDate><guid>http://zput.github.io/post/_posts/%E6%A6%82%E5%BF%B5%E5%8E%9F%E7%90%86%E7%9A%84%E6%80%9D%E8%80%83/synchronous_asynchronous/</guid><description>同步和异步他们的关注点的是消息通信机制 (synchronous communication/ asynchronous communication): 同步，就是调用某个东西时候，调用方得等待这个调用返回结果才能继续往后执行。 异步，和同步相反调用</description></item></channel></rss>