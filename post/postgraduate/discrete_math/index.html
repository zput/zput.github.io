<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><title>离散数学 - Zput's blog</title><meta name=renderer content="webkit"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta http-equiv=cache-control content="no-transform"><meta http-equiv=cache-control content="no-siteapp"><meta name=theme-color content="#f8f5ec"><meta name=msapplication-navbutton-color content="#f8f5ec"><meta name=apple-mobile-web-app-capable content="yes"><meta name=apple-mobile-web-app-status-bar-style content="#f8f5ec"><meta name=author content="zput"><meta name=description content="离散数学 离散数学 数理逻辑 命题逻辑 求主析取/合取范式 真值表发 等值演算法 谓词逻辑 证明法 证明的基本工具 证明方式 演绎法 CP规则 反证法 前束范式 函数 证明"><meta name=keywords content="Hugo,theme,even"><meta name=generator content="Hugo 0.101.0 with theme even"><link rel=canonical href=http://zput.github.io/post/postgraduate/discrete_math/><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/manifest.json><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link href=/sass/main.min.fdb1035139209ff03fa34c28400ff54f04900828b7cafe0d2cfb1f48b70a2ffd.css rel=stylesheet><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin=anonymous><meta property="og:title" content="离散数学"><meta property="og:description" content="离散数学 离散数学 数理逻辑 命题逻辑 求主析取/合取范式 真值表发 等值演算法 谓词逻辑 证明法 证明的基本工具 证明方式 演绎法 CP规则 反证法 前束范式 函数 证明"><meta property="og:type" content="article"><meta property="og:url" content="http://zput.github.io/post/postgraduate/discrete_math/"><meta property="article:section" content="post"><meta itemprop=name content="离散数学"><meta itemprop=description content="离散数学 离散数学 数理逻辑 命题逻辑 求主析取/合取范式 真值表发 等值演算法 谓词逻辑 证明法 证明的基本工具 证明方式 演绎法 CP规则 反证法 前束范式 函数 证明"><meta itemprop=wordCount content="7015"><meta itemprop=keywords content><meta name=twitter:card content="summary"><meta name=twitter:title content="离散数学"><meta name=twitter:description content="离散数学 离散数学 数理逻辑 命题逻辑 求主析取/合取范式 真值表发 等值演算法 谓词逻辑 证明法 证明的基本工具 证明方式 演绎法 CP规则 反证法 前束范式 函数 证明"><!--[if lte IE 9]><script src=https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js></script><![endif]--><!--[if lt IE 9]><script src=https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js></script>
<script src=https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js></script><![endif]--></head><body><div id=mobile-navbar class=mobile-navbar><div class=mobile-header-logo><a href=/ class=logo>Zput</a></div><div class=mobile-navbar-icon><span></span>
<span></span>
<span></span></div></div><nav id=mobile-menu class="mobile-menu slideout-menu"><ul class=mobile-menu-list><a href=/go-goroutine><li class=mobile-menu-item>go源码专栏</li></a><a href=/post/postgraduate/><li class=mobile-menu-item>考研知识专栏</li></a><a href=/post/><li class=mobile-menu-item>时间线</li></a><a href=/categories/><li class=mobile-menu-item>技术类别</li></a></ul></nav><div class=container id=mobile-panel><header id=header class=header><div class=logo-wrapper><a href=/ class=logo>Zput</a></div><nav class=site-navbar><ul id=menu class=menu><li class=menu-item><a class=menu-item-link href=/go-goroutine>go源码专栏</a></li><li class=menu-item><a class=menu-item-link href=/post/postgraduate/>考研知识专栏</a></li><li class=menu-item><a class=menu-item-link href=/post/>时间线</a></li><li class=menu-item><a class=menu-item-link href=/categories/>技术类别</a></li></ul></nav></header><main id=main class=main><div class=content-wrapper><div id=content class=content><article class=post><header class=post-header><h1 class=post-title>离散数学</h1><div class=post-meta><span class=post-time>0001-01-01</span></div></header><div class=post-toc id=post-toc><h2 class=post-toc-title>文章目录</h2><div class="post-toc-content always-active"><nav id=TableOfContents><ul><li><ul><li><a href=#离散数学>离散数学</a></li><li><a href=#数理逻辑>数理逻辑</a><ul><li><a href=#命题逻辑>命题逻辑</a></li><li><a href=#谓词逻辑>谓词逻辑</a></li><li><a href=#函数>函数</a></li><li><a href=#集合>集合</a></li><li><a href=#关系>关系</a></li></ul></li><li><a href=#每个节点都有子环>每个节点都有子环</a><ul><li></li><li><a href=#图>图</a></li></ul></li><li><a href=#代数系统>代数系统</a><ul><li><a href=#半群>半群</a></li><li><a href=#群>群</a></li><li><a href=#同态同构>同态/同构</a></li></ul></li><li><a href=#快速回顾>快速回顾</a></li><li><a href=#附录>附录</a></li></ul></li></ul></nav></div></div><div class=article-container><div class=post-content><h2 id=离散数学>离散数学</h2><ul><li><a href=#%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6>离散数学</a></li><li><a href=#%E6%95%B0%E7%90%86%E9%80%BB%E8%BE%91>数理逻辑</a><ul><li><a href=#%E5%91%BD%E9%A2%98%E9%80%BB%E8%BE%91>命题逻辑</a><ul><li><a href=#%E6%B1%82%E4%B8%BB%E6%9E%90%E5%8F%96%E5%90%88%E5%8F%96%E8%8C%83%E5%BC%8F>求主析取/合取范式</a><ul><li><a href=#%E7%9C%9F%E5%80%BC%E8%A1%A8%E5%8F%91>真值表发</a></li><li><a href=#%E7%AD%89%E5%80%BC%E6%BC%94%E7%AE%97%E6%B3%95>等值演算法</a></li></ul></li></ul></li><li><a href=#%E8%B0%93%E8%AF%8D%E9%80%BB%E8%BE%91>谓词逻辑</a><ul><li><a href=#%E8%AF%81%E6%98%8E%E6%B3%95>证明法</a><ul><li><a href=#%E8%AF%81%E6%98%8E%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%B7%A5%E5%85%B7>证明的基本工具</a></li><li><a href=#%E8%AF%81%E6%98%8E%E6%96%B9%E5%BC%8F>证明方式</a><ul><li><a href=#%E6%BC%94%E7%BB%8E%E6%B3%95>演绎法</a></li><li><a href=#cp%E8%A7%84%E5%88%99>CP规则</a></li><li><a href=#%E5%8F%8D%E8%AF%81%E6%B3%95>反证法</a></li></ul></li></ul></li><li><a href=#%E5%89%8D%E6%9D%9F%E8%8C%83%E5%BC%8F>前束范式</a></li></ul></li><li><a href=#%E5%87%BD%E6%95%B0>函数</a><ul><li><a href=#%E8%AF%81%E6%98%8E%E5%8D%95%E5%B0%84-%E6%BB%A1%E5%B0%84%E5%92%8C%E5%8F%8C%E5%B0%84%E5%8D%95%E5%B0%84%E6%BB%A1%E5%B0%84>证明单射、满射和双射(单射+满射)</a></li></ul></li><li><a href=#%E9%9B%86%E5%90%88>集合</a></li><li><a href=#%E5%85%B3%E7%B3%BB>关系</a><ul><li><a href=#%E5%BA%8F%E5%81%B6%E7%9A%84%E9%9B%86%E5%90%88%E7%94%A8r>序偶的集合用R</a><ul><li><a href=#%E5%85%B3%E7%B3%BB%E5%9B%BE%E5%85%B3%E7%B3%BB%E7%9F%A9%E9%98%B5>关系图/关系矩阵</a></li></ul></li><li><a href=#%E4%BA%94%E4%B8%AA%E5%85%B3%E7%B3%BB>五个关系</a><ul><li><a href=#%E8%BF%90%E7%AE%97>运算</a></li><li><a href=#%E7%AD%89%E4%BB%B7-%E5%81%8F%E5%BA%8F-%E6%8B%9F%E5%BA%8F>=(等价) &lt;=(偏序) &lt;(拟序)</a></li></ul></li><li><a href=#%E4%B8%80%E4%BA%9B%E7%94%A8%E8%AF%8D>一些用词</a></li><li><a href=#%E9%A2%98%E5%9E%8B>题型</a><ul><li><a href=#%E5%85%B3%E7%B3%BB%E7%9F%A9%E9%98%B5%E5%88%A4%E6%96%AD%E8%87%AA%E5%8F%8D%E5%AF%B9%E7%A7%B0%E4%BC%A0%E9%80%92>关系矩阵判断自反/对称/传递</a></li><li><a href=#%E6%9C%80%E5%A4%A7%E5%B0%8F%E5%85%83-%E6%9E%81%E5%A4%A7%E5%B0%8F%E5%85%83-%E4%B8%8A%E4%B8%8B%E7%95%8C>最大/小元-极大/小元-上/下界</a></li><li><a href=#%E6%B1%82%E9%9B%86%E5%90%88%E7%9A%84%E5%88%92%E5%88%86>求集合的划分</a></li><li><a href=#%E6%B1%82%E5%85%B3%E7%B3%BBr%E5%9C%A8a%E5%88%B0b%E5%8F%AF%E8%83%BD%E4%B8%BAa%E5%88%92%E5%88%86%E5%9D%97>求关系R在A到B(可能为A)划分块</a></li></ul></li></ul></li><li><a href=#%E5%9B%BE>图</a><ul><li><a href=#%E7%9F%A9%E9%98%B5>矩阵</a><ul><li><a href=#colorred%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5>${\color{Red}邻接矩阵}$</a></li></ul></li><li><a href=#%E9%82%BB%E6%8E%A5%E7%82%B9-%E9%82%BB%E6%8E%A5%E8%BE%B9>邻接点-邻接边</a></li><li><a href=#%E5%9B%BE%E7%9A%84%E5%88%86%E7%B1%BB>图的分类</a></li><li><a href=#%E5%BA%A6>度</a></li><li><a href=#%E9%80%9A%E8%B7%AF%E5%9B%9E%E8%B7%AF>通路/回路</a></li><li><a href=#%E8%BF%9E%E9%80%9A%E8%80%8C%E4%B8%8D%E5%90%AB%E5%9B%9E%E8%B7%AF%E5%9B%BE%E6%97%A0%E5%90%91%E6%A0%91%E7%AE%80%E7%A7%B0colorred%E6%A0%91>连通而不含回路图(无向树)(简称${\color{red}树}$)</a><ul><li><a href=#colorred%E4%BA%8C%E5%8F%89%E6%A0%91-%E6%A0%91%E5%85%B3%E4%BA%8E%E5%BA%A6%E7%9A%84%E6%80%BB%E7%BB%93>${\color{red}二叉树-树，关于度的总结}$</a></li><li><a href=#%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91>最小生成树</a></li></ul></li><li><a href=#colorred%E7%89%B9%E6%AE%8A%E5%9B%BE>${\color{red}特殊图}$</a><ul><li><a href=#%E6%AC%A7%E6%8B%89%E5%9B%BE>欧拉图</a></li><li><a href=#%E5%93%88%E5%AF%86%E9%A1%BF%E5%9B%BE>哈密顿图</a></li><li><a href=#%E5%81%B6%E5%9B%BE%E4%BA%8C%E5%88%86%E5%9B%BE%E4%BA%8C%E9%83%A8%E5%9B%BE%E6%9C%89%E4%B8%AA%E5%81%B6%E5%AD%97%E6%89%80%E6%9C%89%E5%9B%9E%E8%B7%AF%E9%83%BD%E6%98%AF%E5%81%B6%E6%95%B0>偶图(二分图/二部图);有个<strong>偶</strong>字，所有回路都是偶数</a></li></ul></li><li><a href=#%E9%A2%98%E5%9E%8B-1>题型</a><ul><li><a href=#%E8%BF%9E%E9%80%9A%E5%88%A4%E6%96%AD>连通判断</a></li><li><a href=#%E6%B1%82%E5%BA%A6%E6%95%B0%E5%BA%8F%E5%88%97%E6%98%AF%E5%90%A6%E5%8F%AF%E5%9B%BE>求度数序列是否可图</a></li><li><a href=#%E8%87%B3%E5%B0%91%E6%9C%89%E5%A4%9A%E5%B0%91%E4%B8%AA%E7%BB%93%E7%82%B9>至少有多少个结点</a></li></ul></li></ul></li></ul></li><li><a href=#%E4%BB%A3%E6%95%B0%E7%B3%BB%E7%BB%9F>代数系统</a><ul><li><a href=#%E5%8D%8A%E7%BE%A4>半群</a></li><li><a href=#%E7%BE%A4>群</a><ul><li><a href=#%E6%B1%82%E5%AD%90%E7%BE%A4>求子群</a><ul><li><a href=#%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E5%AE%9A%E7%90%86>拉格朗日定理</a></li><li><a href=#%E7%BE%A4%E7%9A%84%E9%98%B6>群的阶</a></li><li><a href=#%E7%94%A8%E7%BE%A4%E7%9A%84%E9%98%B6%E5%AD%90%E7%BE%A4%E7%9A%84%E9%98%B6>用群的阶/子群的阶</a></li><li><a href=#%E5%91%A8%E6%9C%9F>周期</a></li><li><a href=#%E7%BE%A4%E7%9A%84%E9%98%B6-1>群的阶</a></li><li><a href=#%E7%94%9F%E6%88%90%E5%85%83>生成元</a></li></ul></li><li><a href=#%E8%AF%81%E6%98%8E%E7%BE%A4h-%E6%98%AF%E7%BE%A4g-%E7%9A%84%E5%AD%90%E7%BE%A4>证明群&lt;H, *>是群&lt;G, *>的子群</a></li><li><a href=#%E5%B7%A6%E5%8F%B3%E9%99%AA%E7%BE%A4>左右陪群</a></li></ul></li><li><a href=#%E5%90%8C%E6%80%81%E5%90%8C%E6%9E%84>同态/同构</a></li></ul></li><li><a href=#%E5%BF%AB%E9%80%9F%E5%9B%9E%E9%A1%BE>快速回顾</a></li><li><a href=#%E9%99%84%E5%BD%95>附录</a></li></ul><h2 id=数理逻辑>数理逻辑</h2><h3 id=命题逻辑>命题逻辑</h3><ul><li><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20220316125135.png alt=20220316125135></li></ul><blockquote><ul><li>析取 $\vee $ -> 或 => 子句 + $\wedge$ => <strong>合取范式</strong>(可以指出公式何时为假) => ${\color{Red} 极小项-> \wedge (并集就为极小)}$ => 默认为1(小字的中间为1),它的反为0</li><li>合取 $\wedge$ -> 且 => 短语 + $\vee$ => <strong>析取范式</strong>(可以指出公式何时为真,有一个为真那么就为真) => ${\color{Red} 极大项-> \vee (联合(或)起来看谁大)}$ => 默认为0,它的反为1</li></ul></blockquote><hr><blockquote><ul><li>主析取范式:每个短语(${\color{Red} 主析取(\vee, 它的反(\wedge),也就是短语 }$)是极小项,按照编码从小到大排列</li><li>主合取范式:每个子句是极大项,按照编码从小到大排列</li></ul></blockquote><ul><li><p>判断蕴含的真假</p><ul><li><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20220316131020.png alt=20220316131020></li></ul></li><li><p>极大/极小的编码方式记忆，成假/真</p><ul><li><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20220316133659.png alt=20220316133659><ul><li>极大项是让它真值结果为假，要让它析取为假，需让它每一项为假，$ P \vee \neg Q \vee R: \quad M_{010}\left(M_{2}\right) $<ul><li><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20220316133943.png alt=20220316133943></li></ul></li></ul></li></ul></li></ul><hr><h5 id=求主析取合取范式>求主析取/合取范式</h5><h6 id=真值表发>真值表发</h6><ul><li><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20220316135523.png alt=20220316135523></li><li>极小项&lt;=>合取$\wedge$</li><li>极大项&lt;=>析取$\vee$<ul><li>成真赋值 $ \overset{\bold{真}在析取/合取的那个难度大些? 合取难度大些，要都为真才会为真}{=>}$ 合取$\wedge$ => 极小项</li><li>成真赋值 => 合取 $\overset{那么把这些合取再做析取的话}{=>}$ 主析取范式</li></ul></li></ul><h6 id=等值演算法>等值演算法</h6><p>$\neg P \wedge P = 0 $
$\neg P \vee P = 1 $</p><p>当缺P的公式中，其他项之间是用 $\vee$ ; 那么需要加 $\neg P \wedge P $ (零)
当缺P的公式中，其他项之间是用 $\wedge$ ; 那么需要加 $\neg P \vee P $ (一)</p><ul><li><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20220316140636.png alt=20220316140636></li></ul><h3 id=谓词逻辑>谓词逻辑</h3><ul><li><p><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20220314180538.png alt=20220314180538></p></li><li><p>P(x,y), P才是谓词</p></li><li><p>全称/存在量词。</p></li></ul><hr><h4 id=证明法>证明法</h4><ul><li>$\neg G => \neg G \vee H \overset{G->H = \neg G \vee H}{=>} G->H$</li></ul><h5 id=证明的基本工具>证明的基本工具</h5><ul><li>等价<code>[=]</code>变形(E)<ul><li><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20220315220107.png alt=20220315220107></li><li><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20220316150712.png alt=20220316150712></li></ul></li><li>推理<code>也叫蕴含[=>]</code>(I)nfer:<ul><li>如果所有前提的合取为真，则结论为真,如果<code>GvH</code>为真，则G或H有一个为真, $\neg G$ 为真，则G为假，则H为真</li><li><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20220324103215.png alt=20220324103215></li></ul></li><li>推理规则:US,ES,UG,EG<ul><li>US(全称指定规则 Universal Specify)</li><li>ES(存在指定规则 Exstential Specify)</li><li>UG(全称推广规则 Universal Generalize)</li><li>EG(存在推广规则 Existential Generalize)</li></ul></li></ul><hr><ul><li>P(Premise)规则：就是直接利用推理中给出的前提，即前提引入。</li><li>T(Transformation)规则：就是由某一个或几个前提可以通过等价、蕴含得到其他命题公式，即推理规则。<ul><li>I表示在T规则中通过蕴含式推出其他命题公式，即推理规则中的蕴含推理。</li><li>E表示在T规则中通过等价式推出其他命题公式，即推理规则中的置换(等价)规则。</li></ul></li><li>CP(Conclusion Premise)规则即附加前提引入，在最后使用。${\color{Red}C,P => S; C => P->S}$<ul><li>如能从给定的前提集合C与公式P推导出S，则能从此前提集合C推导出$P\rightarrow S$</li></ul></li></ul><hr><ul><li>→与⇒<ul><li>命题逻辑中的"→"符号表示了一个命题。比如说p→q，代表的是${\color{Red} &ldquo;p为真时，q为真"这么一个命题。而这个命题可能是真的，也可能是假的。}$我们在给出命题"p→q"时，目的就是为了去判别命题的真假。（或者以此命题为依据来判别其他命题的真假）</li><li>而数学中的"⇒"符号表示了一个对事实的陈述，意思就是当我们说"p⇒q"时相当于断言 ${\color{Red}&rdquo; 命题p→q为真"。 }$<ul><li>而我们使用"⇒"符号是为了以"p→q"这个已经被证明过的命题为前提，去判断p或q的真实性，而不是去研究命题本身的真值。</li></ul></li></ul></li></ul><h5 id=证明方式>证明方式</h5><ul><li></li></ul><h6 id=演绎法>演绎法</h6><ul><li><ol><li>消去量词</li></ol><ul><li>那么它的量词的消去有顺序？是的，先用ES在用US.</li></ul></li><li><ol start=2><li>无量词</li></ol><ul><li>使用基本等价公式，基本蕴含公式</li></ul></li><li><ol start=3><li>添加量词</li></ol></li></ul><p><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20220315120551.png alt=20220315120551></p><h6 id=cp规则>CP规则</h6><ul><li>CP(Conclusion Premise)规则即附加前提引入，在最后使用。${\color{Red}C,P => S; C => P->S}$<ul><li>如能从给定的前提集合C与公式P推导出S，则能从此前提集合C推导出$P\rightarrow S$</li></ul></li></ul><p><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20220315111028.png alt=20220315111028></p><h6 id=反证法>反证法</h6><ul><li><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20220315105915.png alt=20220315105915></li></ul><h4 id=前束范式>前束范式</h4><ul><li><p><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20220324190312.png alt=20220324190312></p><ul><li>首先去除蕴含等值(使用蕴含式 )</li><li>然后使用量词否定等值<ul><li>换名规则；</li></ul></li><li>最后辖域扩张/收缩；</li></ul></li><li><p><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20220325122307.png alt=20220325122307></p></li></ul><hr><h3 id=函数>函数</h3><ul><li></li></ul><h4 id=证明单射满射和双射单射满射>证明单射、满射和双射(单射+满射)</h4><ul><li><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20220319141800.png alt=20220319141800></li></ul><blockquote><ul><li><p>证明单射:证明当x≠y时，f(x)≠f(y)，可以取x和x+1等</p></li><li><p>证明满射:证明对于所有的b∈B，存在a∈A，使得f(a)=b</p></li><li><p>设R为实数集合，定义f: RXR -> RXR为<code>f(&lt;x,y>)=&lt;x+2y,x-2y></code> 其中x，y属于R，证明f是双射</p><ul><li>$\begin{array}{l} \forall&lt;x,y>,&lt;x+1,y+1> \in RxR,其中x,y \in R \ 有f(&lt;x,y>)=&lt;x+2y,x-2y>; f(&lt;x+1,y+1>)=&lt;x+2y+1, x-2y-1> \ 而x+2y \ne x+2y+1; x-2y \ne x-2y-1 \ 得f是单射 \end{array}$</li><li>$ \begin{array}{l} 令&lt;x,y>&lt;u,v>\in RxR,其中 \ 令u=x+y ; v=x-2y\ 得 x=\frac{1}{2}(u+v); y=\frac{1}{4}(u-v)，所以对任意u,v都存在x,y表示 \ f是满射 \end{array} $</li></ul></li></ul></blockquote><blockquote><ul><li><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20220319141842.png alt=20220319141842></li></ul></blockquote><h3 id=集合>集合</h3><ul><li><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20220319141723.png alt=20220319141723></li></ul><h3 id=关系>关系</h3><ul><li><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20220317122958.png alt=20220317122958></li></ul><h4 id=序偶的集合用r>序偶的集合用R</h4><ul><li>有序对(序偶)的集合用R<ul><li><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20220318114035.png alt=20220318114035></li></ul></li></ul><blockquote><ul><li>嵌套的二元关系<ul><li>当是一元关系的时候:<img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20220318202115.png alt=20220318202115><ul><li>${&lt;x,x>|x\in A}$</li></ul></li><li>&#171;a,b>,&lt;c,d&#187;这种: <img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20220318202102.png alt=20220318202102><ul><li>${&#171;a,b>,&lt;a,b&#187;| &lt;a,b> \in AxA | a,b \in A}$<ul><li>$E_A = {&lt;1,1>,&lt;1,2>,&lt;1,3>,&lt;2,1>,&lt;2,2>&lt;2,3>,&lt;3,1>,&lt;3,2>,&lt;3,3>} $<ul><li>嵌套的I为 $ {\langle\langle 1,1\rangle,\langle 1,1\rangle\rangle,\langle\langle 1,2\rangle,\langle 1,2\rangle\rangle,\langle\langle 1,3\rangle,\langle 1,3\rangle\rangle,\langle\langle 2,1\rangle,\langle 2,1\rangle\rangle,\langle\langle 2,2\rangle,\langle 2,2\rangle\rangle , \langle\langle 2,3\rangle,\langle 2,3\rangle\rangle,\langle\langle 3,1\rangle,\langle 3,1\rangle\rangle,\langle\langle 3,2\rangle,\langle 3,2\rangle\rangle,\langle\langle 3,3\rangle,\langle 3,3\rangle\rangle} $</li></ul></li></ul></li></ul></li></ul></li></ul></blockquote><h5 id=关系图关系矩阵>关系图/关系矩阵</h5><ul><li>邻接矩阵用 $M_R$<ul><li><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20220318113502.png alt=20220318113502></li></ul></li><li>关系图用$G_R$<ul><li><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20220318113641.png alt=20220318113641></li></ul></li></ul><h4 id=五个关系>五个关系</h4><ul><li><p>r(R)自反(Reverse): 首先仅有自己，自己反应该结果就是&lt;自己,自己></p><ul><li><h2 id=每个节点都有子环>每个节点都有子环</h2></li></ul></li><li><p>s(R)对称(Symmetric): 就不需要管&lt;x,y>;$x\overset{不用管是否相等}{==}y$</p></li><li><p>反对称: 就需要对<code>&lt;x,y>;x==y</code>,这种开恩</p><ul><li>因为它实际上不算是对称，它是自己内部本身就对称</li><li>任何一对节点之间至多只有一条边</li></ul></li><li><p>t(R)传递(Transfer)</p><ul><li>x到y有一条边,y到z有一条边,那么x到z也会有一条边</li></ul></li></ul><h5 id=运算>运算</h5><ul><li>闭包是只能增加元素对，那么只能是<strong>自反，对称，传递</strong><ul><li>反自反: 需要某某不在里面, 那么如果它开始不是反自反(比如是自反,然后需要去掉<code>&lt;x,y>;x==y</code>)</li></ul></li></ul><hr><h5 id=等价-偏序-拟序>=(等价) &lt;=(偏序) &lt;(拟序)</h5><ul><li><p>是某某集合上的关系:</p><ul><li><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20220317113739.png alt=20220317113739></li></ul></li><li><p>等价关系与偏序关系,只是对称/反对称这一点不一致;</p><ul><li>偏序了，肯定不是对称了,反对称.</li></ul></li><li><p>偏序关系(局部序关系partial order)-全序关系:</p><ul><li>集合A包含B则称A大于B，显然存在两个集合互相不包含，那么这两个集合就没发比大小</li><li>全序关系就是偏序关系，只不过它 ${x,y\in A | x\le y \vee y\le x}$</li><li>偏序关系就是指存在“序”这个概念，满足自反性、反对称性和传递性。但是并不是任何两个元素之间都有这个序的先后关系。比如集合之间的包含关系，就是一个偏序关系。但并不是任何两个集合之间都存在包含关系。<ul><li>感谢这个答案，我从本科就没办法根据教科室和老师的解释深入理解“偏序”这个概念。遇到它，我要么忘记它的涵义，要么还得看定义再次理解。看了你的回答后我马上就明白了，”局部“这个解释才是对的，最“数学”的解释，肯定忘不了(数学上不就用partial表示“局部”的意思吗)。“偏序”这个中文翻译有问题，要是我就翻译成“局部序”，简单直接明了，而且数学上经常讲"局部"，并不会讲"偏颇、偏心"。“偏”字跟“局部”毫无关系。第一个用“partial order"这个词的外国人，肯定是取"partial"这个字的"局部的"这个意思吧，取个"偏心的，不公平的"就没了数学上的意义。母语英语的一看”partial order“即便不懂也明白大概，母语汉语的一看”偏序“就懵逼（我实在是没有办法让它跟”偏“联系起来）。</li></ul></li></ul></li><li><p>良序集-全序集</p><ul><li>良序集 [2] 是任意非空子集都有最小元的全序集。</li></ul></li><li><p>偏序关系: &lt;=关系.</p></li><li><p>拟序关系: 实数集上的小于关系是拟序关系. <code>&lt;</code></p><ul><li><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20220317195324.png alt=20220317195324></li></ul></li></ul><hr><ul><li><p>最大/小;极大/小;上/下界;确界;都为${\color{red}偏序集(也就是\le)}$</p></li><li><p>最大元: 比任何其他元素都</p></li><li><p>极大元: 如果b小于等于某个元素,那么这个元素一定是它自己</p></li><li><p>上下确界:上界里面取最小，下界里面取最大</p><ul><li><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20220317194626.png alt=20220317194626></li></ul></li></ul><blockquote><p>哈斯图: 1>求出所有相关的集合(不包括$I_A$中的) ${\color{red}最好按照前件相同的放同一行}$ 2>去掉所有的传递 3> ${\color{red} 从最顶上开始画起，一步一步画好就行了}$</p><blockquote><ul><li><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20220326202644.png alt=20220326202644></li></ul><blockquote><ul><li><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20220326204234.png alt=20220326204234></li></ul></blockquote></blockquote></blockquote><hr><ul><li>偏序关系: 这个东东 自反/反对称/传递 ${\color{Red} 怎么记住呢，想象下，小于是拟序; 小于等于是偏序}$<ul><li>去掉环</li><li>去掉传递的</li></ul></li></ul><h4 id=一些用词>一些用词</h4><ul><li>树用T</li><li>划分用 $\pi$</li><li>二次方的邻接矩阵 $M_{R^2}$</li><li>等于的偏序关系 $I_A$</li><li>入度deg+(vi)</li><li>集合的矩阵和图的矩阵不一样 !!!<ul><li>图的矩阵不一定只是 1 !!!</li></ul></li></ul><h4 id=题型>题型</h4><h5 id=关系矩阵判断自反对称传递>关系矩阵判断自反/对称/传递</h5><blockquote><blockquote><ul><li><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20220318124540.png alt=20220318124540></li></ul><blockquote><ul><li><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20220326150522.png alt=20220326150522></li></ul></blockquote></blockquote></blockquote><h5 id=最大小元-极大小元-上下界>最大/小元-极大/小元-上/下界</h5><blockquote><blockquote><p><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20220317211454.png alt=20220317211454></p></blockquote></blockquote><h5 id=求集合的划分>求集合的划分</h5><blockquote><p>不同关系个数: $ 2^{|A|*|B|} $
不同函数个数: $ |B|^{|A|} $</p><ul><li><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20220326131429.png alt=20220326131429></li></ul></blockquote><hr><blockquote><ul><li><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20220317232954.png alt=20220317232954><ul><li><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20220317232703.png alt=20220317232703><ul><li><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20220317233159.png alt=20220317233159></li></ul></li></ul></li></ul></blockquote><h5 id=求关系r在a到b可能为a划分块>求关系R在A到B(可能为A)划分块</h5><blockquote><ul><li><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/decreate_math.drawio.png alt=decreate_math.drawio></li></ul></blockquote><h3 id=图>图</h3><ul><li><p><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20220319164108.png alt=20220319164108></p></li><li><p>按连通性分类:</p></li><li><p>按平行边分类:</p><ul><li>平行边:<ul><li>在有向图中，两结点间 (包括结点自身间) 若有同始点和同终点的几条边，则这几条边 称为平行边；</li><li>在无向图中，两结点间 (包括结点自身间) 若有几条边，则这几条边称 为平行边。</li><li>两结点 a 、 b 间相互平行的边的条数称为边 (a, b) 或 &lt;a, b> 的重数。</li></ul></li><li><strong>含有</strong>平行边的图称为多重图(multigraph)；</li><li>(<em>不含有平行边的图</em>)非多重图称为线图(line graph)；<ul><li>无环的线图称为${\color{red}简单图(simple graph)}$。</li></ul></li></ul></li></ul><hr><ul><li>握手定理: 总度数=2m</li><li>树: m=(n-1)<ul><li><code>总度数=2 * (结点数 - 1)</code></li></ul></li><li>平面图:面的次数=2*m<ul><li>⚠️:桥，它的面次数为2</li></ul></li></ul><hr><p>图的表示方法</p><h4 id=矩阵>矩阵</h4><p>如果是求通路/回路的个数，那么矩阵里面应该是边数目。
如果是求可达->区分是强连通/弱连通/单连通:</p><ul><li>那么就使用邻接矩阵</li></ul><h5 id=colorred邻接矩阵>${\color{Red}邻接矩阵}$</h5><ul><li><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20220308135417.png alt=20220308135417></li><li><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20220320180715.png alt=20220320180715></li></ul><h4 id=邻接点-邻接边>邻接点-邻接边</h4><ul><li><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20220308135002.png alt=20220308135002></li></ul><h4 id=图的分类>图的分类</h4><ul><li><p>多重图->线图->简单图:</p><ul><li><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20220308140456.png alt=20220308140456></li></ul></li><li><p>子图</p><ul><li><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20220308142043.png alt=20220308142043></li></ul></li><li><p>完全图</p><ul><li><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20220308142152.png alt=20220308142152></li></ul></li><li><p>补图</p><ul><li><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20220308152453.png alt=20220308152453></li><li><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20220308152806.png alt=20220308152806></li></ul></li></ul><h4 id=度>度</h4><ul><li><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20220308160506.png alt=20220308160506><ul><li>握手定理<ul><li><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20220308174850.png alt=20220308174850></li></ul></li><li>同构<ul><li><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20220308180036.png alt=20220308180036></li></ul></li></ul></li></ul><h4 id=通路回路>通路/回路</h4><ul><li><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20220308180423.png alt=20220308180423><ul><li><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20220309174802.png alt=20220309174802><ul><li><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20220309175435.png alt=20220309175435></li></ul></li></ul></li></ul><hr><ul><li><p>是否可达:</p><ul><li><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20220309182154.png alt=20220309182154></li><li>$ 长度为k的通路=>有k+1个节点 $<ul><li>$设 v_{i_{0} 0} v_{i_{1}} \cdots v_{i_{k}} 为从 v_{i} 到 v_{j} 的长度为 k 的一条通路，其中 v_{i_{0}}=v_{i} ， v_{i_{k}}=v_{j} ，此通路上 有 k+1 个结点。若 k \leqslant n-1 ，这条通路即为所求。$</li><li>$ 若 k>n-1 ，则此通路上的结点 数 k+1>n ，{\color{red}由鸽笼原理知，必存在一个结点在此通路中不止一次出现，}设 v_{i_{s}}=v_{i_{t}} ， 其中，0 \leqslant s&lt;t \leqslant k_{0} 去掉 v_{i_{s}} 到 v_{i_{t}} 中间的通路，至少去掉一条边，得通路 v_{i_{0}} v_{i_{1}} \cdots v_{i_{i}} v_{i_{t+1}} \cdots v_{i_{k}} ，此通路比原通路的长度至少小 1_{0} 。$</li></ul></li><li>回路要回到原点，所以它的长度要加一个一。</li><li><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20220309182844.png alt=20220309182844></li></ul></li><li><p><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20220312120418.png alt=20220312120418></p></li><li><p>短程线和距离</p><ul><li><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20220312121346.png alt=20220312121346></li></ul></li><li><p><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20220312165815.png alt=20220312165815></p></li><li><p>有向图的连通性</p><ul><li><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20220312181651.png alt=20220312181651></li></ul></li></ul><h4 id=连通而不含回路图无向树简称colorred树>连通而不含回路图(无向树)(简称${\color{red}树}$)</h4><ul><li><p><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20220319220827.png alt=20220319220827></p></li><li><p>树的性质</p><ul><li><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20220312191302.png alt=20220312191302></li></ul></li><li><p>生成树存在条件/算法</p><ul><li><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20220313110617.png alt=20220313110617></li></ul></li></ul><h5 id=colorred二叉树-树关于度的总结>${\color{red}二叉树-树，关于度的总结}$</h5><ul><li>在二叉树中，总是认为叶子结点的度为0:<ul><li><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20220320192626.png alt=20220320192626></li></ul></li></ul><blockquote><ul><li><p>完全二叉树的定理做题</p><ul><li><ol><li>在二叉树上的第i层上至多有 $2^{(i-1)}$ 个节点(i>=1)</li></ol></li><li><ol start=2><li>深度为k的二叉树至多有 $(2^k)-1$ 个节点(k>=1)</li></ol></li><li><ol start=3><li>具有n个节点的完全二叉树的深度为 └log2n┘+ 1</li></ol></li><li><ol start=4><li>$n_1$ 度为1的顶点数为0或1</li></ol></li><li><ol start=5><li>$n_0、n_1、n_2$ 分别代表节点的度数为0、1、2。</li></ol><ul><li>n为总结点数</li><li>$n_0 = n_2+1$;</li><li>$n=n_0+n_1+n_2$</li><li>$分支总线=n-1=n_1+2*n_2$</li></ul></li></ul></li><li><p><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20220320194932.png alt=20220320194932></p></li></ul></blockquote><ul><li>在离散数学中的树，认为叶子的度为1,且符合握手定理<ul><li><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20220320193132.png alt=20220320193132></li></ul></li></ul><h5 id=最小生成树>最小生成树</h5><ul><li><p><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20220313112945.png alt=20220313112945></p></li><li><p><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20220313123921.png alt=20220313123921></p></li><li><p><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20220313125623.png alt=20220313125623></p></li><li><p>平凡图只有一个节点，没有边</p></li><li><p>连通分支，&ndash;> 去掉某个节点后，图变成了独立的几块</p><ul><li><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20220313170848.png alt=20220313170848></li></ul></li><li><p><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20220313162610.png alt=20220313162610></p></li></ul><h4 id=colorred特殊图>${\color{red}特殊图}$</h4><ul><li><p><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20220319213056.png alt=20220319213056></p></li><li><p>平⾯图、偶图（⼆部图）和欧拉回路、欧拉通路的判定</p><ul><li>${\color{red} 偶图 }$ ⼆部图：所有回路的⻓度均为 ${\color{red} 偶数 }$<ul><li>K5: 是5阶完全图,每一顶点与其他所有顶点都有边.</li><li>k3,3: 是⼆部图.上下顶点分别为3.</li><li><a href=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20220327000600.png>k4:</a></li></ul></li><li><a href=https://blog.csdn.net/zlc_abc/article/details/105966882>平面图:</a><ul><li><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20220327002024.png alt=20220327002024><ul><li>同胚<img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20220314162922.png alt=20220314162922></li></ul></li></ul></li></ul></li><li><p>判断哈密顿图的必要条件:</p><ul><li><strong>若无向图G=&lt;V,E>为哈密顿图，则图G中无割点。</strong><ul><li><ol><li>割点：如果去掉一个点以及与它连接的边，该点原来所在的图被分成两部分（不连通），则称该点为割点。</li></ol></li><li><ol start=2><li>割边：如果去掉一条边，该边原来所在的图被分成两部分（不连通），则称该点为割边。</li></ol></li></ul></li><li><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20220327002636.png alt=20220327002636></li></ul></li><li><p>欧拉公式:</p><ul><li><code>n-m+r=2</code>:n个结点、m 条边和 ${\color{red}r个面(⚠️r代表面的个数,不是次数)}$</li><li>有多个连通分支: $r_总=r+k-1$</li><li>平面图中:⚠️这是错误的 <del>$2m_总=r_总$</del> ,应该是$2*边_总=面次数_总$;⚠️这里没有说某个边一定对应两个面->只能说:${\color{Red}每条边至多被两个面共享}$<ul><li>因任何一条边(或者是两个面边界的公共边，或者是在一个面中作为边界)被重复计算两次，故平 面图所有面的次数之和等于其边数的二倍。<ul><li><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20220320130830.png alt=20220320130830></li><li><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20220320134538.png alt=20220320134538></li></ul></li></ul></li></ul></li></ul><h5 id=欧拉图>欧拉图</h5><ul><li><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20220313165625.png alt=20220313165625></li></ul><blockquote><blockquote><ul><li><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20220326153107.png alt=20220326153107></li></ul></blockquote></blockquote><h5 id=哈密顿图>哈密顿图</h5><ul><li><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20220313173044.png alt=20220313173044></li></ul><blockquote><blockquote><blockquote><ul><li><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20220326155209.png alt=20220326155209></li></ul><blockquote><ul><li><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20220326160700.png alt=20220326160700></li></ul></blockquote></blockquote></blockquote></blockquote><h5 id=偶图二分图二部图有个偶字所有回路都是偶数>偶图(二分图/二部图);有个<strong>偶</strong>字，所有回路都是偶数</h5><ul><li><p><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20220313182444.png alt=20220313182444></p></li><li><p>平面图</p><ul><li><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20220314162511.png alt=20220314162511></li></ul></li><li><p>欧拉公式</p><ul><li><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20220314162613.png alt=20220314162613></li></ul></li></ul><p>简单图不能够有自回路/平行边</p><ul><li><p>自回路：一条边围成一个平面</p></li><li><p>平行边：两条边围成一个平面</p></li><li><p><a href=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20220314161906.png>欧拉推论1</a></p></li><li><p><a href=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20220314161655.png>欧拉推论2</a></p></li><li><p>至少是四</p><ul><li>首先是一个<strong>简单图</strong>&ndash;>所以它每个面的次数至少是三</li><li>偶图&ndash;>回路的长度应该都是偶数</li></ul></li></ul><h4 id=题型-1>题型</h4><h5 id=连通判断>连通判断</h5><ul><li><p>可达性矩阵P:用邻接矩阵求得，利用传递性，直到N次方，$\vee$ 起来就行(如果中间有和前面一样的就中止)</p></li><li><p>强连通:求p，如果不是全1，则不是强连通图</p></li><li><p>弱连通图:求邻接矩阵 $A \vee A^T$ ，再对它求可达性矩阵，所有元素都是1就是弱连通图</p></li><li><p>单向连通图:求 $p^T \vee p$ ，如果除了对⻆线全为1，则是单向连通图</p></li><li><p>强连通<strong>分</strong>图:求 $ P^T \wedge P $ ，得到的对称矩阵，就可以算那些是连通的</p><ul><li>TODO</li></ul></li></ul><h5 id=求度数序列是否可图>求度数序列是否可图</h5><ul><li>可图（Graphic）: 就是如果一串度序列可以逆向生成出图，就是可图的。而判断一个序列是否是可图的，则由Havel-Hakimi定理判断。<ul><li>什么是可图，那需要先说一下度序列。<ul><li>度序列是把图的多有顶点度数排列成一个序列s，则称s为图G的度序列。</li><li>度序列可以是按照顶点的顺序排列，也可以按照递增、递减的顺序排列。所谓的可图，是建立在度序列的基础上的。</li></ul></li><li>序列是可图的：一个非负整数组成的有限序列如果是某个无向图的度序列，则称这个序列是可图的</li></ul></li></ul><p>4，判定过程：（1）对当前数列排序，使其呈递减，（2）从S【2】开始对其后S【1】个数字-1，（3）一直循环直到当前序列出现负数（即不是可图的情况）或者当前序列全为0 （可图）时退出。</p><blockquote><ul><li>握手定理1:度数和必须为偶数</li><li>握手定理2(Havel-Hakimi定理):由非负整数组成的有限非递增序列，S={d1,d2,d3&mldr;dn}，当且仅当S1={d2-1,d3- 1&mldr;d(d1+1),d(d1+2)&mldr;&mldr;dn}也是可图的，也就是说，序列S1也是由 非负整数组成的有限非递增序列，S1是由S的删除第一个元素d1之 后的前d1个元素分别减一后得到的序列。</li></ul></blockquote><blockquote><ul><li><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20220320185344.png alt=20220320185344><ul><li><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20220326231549.png alt=20220326231549></li></ul></li></ul></blockquote><h5 id=至少有多少个结点>至少有多少个结点</h5><blockquote><ul><li><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20220326232803.png alt=20220326232803></li></ul></blockquote><h2 id=代数系统>代数系统</h2><ul><li><p><code>((fog)oh)(x)=h(g(f(x)))</code></p></li><li><p><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20220321152147.png alt=20220321152147></p></li><li><p><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20220321144627.png alt=20220321144627></p></li></ul><p>幺元-1元:1乘以任何元素等于自己
零元-0元:0乘以任何元素都等于零元</p><ul><li><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20220321151353.png alt=20220321151353></li></ul><blockquote><blockquote><ul><li><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20220326214718.png alt=20220326214718><ul><li><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20220326221139.png alt=20220326221139></li></ul></li></ul></blockquote></blockquote><ul><li><p>性质</p><ul><li><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20220321152119.png alt=20220321152119></li></ul></li><li><p><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20220321161753.png alt=20220321161753></p><ul><li><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20220322003324.png alt=20220322003324></li></ul></li></ul><h3 id=半群>半群</h3><ul><li><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20220321231948.png alt=20220321231948></li></ul><h3 id=群>群</h3><ul><li><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20220322000335.png alt=20220322000335></li></ul><h4 id=求子群>求子群</h4><ul><li>求某个数的正因子: 1和它自身是一定在的，然后分解它，找出所有的因子就行；比如15，{1,15},然后3*5=15;所以{1,3,5,15}<ul><li><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20220322151227.png alt=20220322151227><ul><li>8的正因子: $2^3=8$ -> 0,1,2,3四个正因子-> ${2^0,2^1,2^2,2^3}$</li><li>15的正因子: $3^1<em>5^1=15$ -> 0,1 | 0, 1 => 2</em>2 = 4五个正因子-> ${3^0<em>5^0,3^0</em>5^1,3^1<em>5^0,3^1</em>5^1,}$ = {1,5,3,15}</li></ul></li></ul></li></ul><h5 id=拉格朗日定理>拉格朗日定理</h5><ul><li><code>设 &lt; H , ∗ > &lt;H,*>&lt;H,∗> 是群 &lt; G , ∗ > &lt;G,* >&lt;G,∗>的一个子群，则子群 H 的阶 m 必然能够整除群 G 的阶 n, 即m∣n。</code><ul><li><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20220326122453.png alt=20220326122453></li></ul></li><li><a href=https://blog.csdn.net/qq_25847123/article/details/100318620>https://blog.csdn.net/qq_25847123/article/details/100318620</a></li></ul><h5 id=群的阶>群的阶</h5><ul><li>$ 如果群 G 只有有限个元素, 我们称它为有限群. 其元素的个数称为群 G 的阶, 记为 |G| , 否则称它为无限群, 记 |G|=\infty $</li></ul><h5 id=用群的阶子群的阶>用群的阶/子群的阶</h5><ul><li><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20220322164526.png alt=20220322164526><ul><li><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20220322163942.png alt=20220322163942></li><li>所以就成功了,反过来想，先用群的阶/子群的阶 === <strong>子群中最小的那个 &ndash;> 由它推出剩下的</strong></li></ul></li></ul><h5 id=周期>周期</h5><ul><li><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20220322004346.png alt=20220322004346><ul><li><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20220326124720.png alt=20220326124720></li></ul></li></ul><p>补充个集合非空</p><hr><h5 id=群的阶-1>群的阶</h5><p>有限群是具有有限多个元素的群。其所包含的个数，称为有限群的阶。</p><p>假若群G是一个有限群，则组成G的元的个数为G的阶，记为|G|。</p><p>比如 素数阶的有限群都是循环群。</p><h5 id=生成元>生成元</h5><ul><li><p>群中元素可以由最小数目个群元的乘积生成，这组群元称为该群的生成元，生成元的数目为有限群的秩。</p></li><li><p>秩：生成元的<strong>数目</strong>为有限群的<strong>秩</strong>。有限群的生成元的选择不唯一，但秩不变。</p></li></ul><h4 id=证明群h-是群g-的子群>证明群&lt;H, *>是群&lt;G, *>的子群</h4><ul><li>判定定理:设S是群&lt;G, *>的非空子集，S是群G的子群的充分必要条件是:对所有a，b∈S，都有 $ a * b^{-1} ∈ S $<ul><li><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20220322234633.png alt=20220322234633></li></ul></li></ul><h4 id=左右陪群>左右陪群</h4><ul><li><p><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20220322234314.png alt=20220322234314></p></li><li><p><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20220326121234.png alt=20220326121234></p></li></ul><h3 id=同态同构>同态/同构</h3><ul><li><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20220322233222.png alt=20220322233222></li></ul><h2 id=快速回顾>快速回顾</h2><ul><li><p><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20220323085326.png alt=20220323085326></p></li><li><p><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20220323085349.png alt=20220323085349></p></li><li><p><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20220325085945.png alt=20220325085945></p></li></ul><hr><p><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20220314172906.png alt=20220314172906></p><h2 id=附录>附录</h2><ul><li><p><a href="https://www.bilibili.com/video/BV1W44y1J7LF/?spm_id_from=pageDriver">https://www.bilibili.com/video/BV1W44y1J7LF/?spm_id_from=pageDriver</a></p></li><li><p><a href=https://www.zhihu.com/question/276859264/answer/462016318>https://www.zhihu.com/question/276859264/answer/462016318</a></p></li><li><p>网盘：https://www.dashengpan.com/#/main/search?keyword=%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6&searchtype=0</p></li><li><p>离散数学:绩加加 <a href="https://www.bilibili.com/video/BV1Hi4y1o7Mo?spm_id_from=333.999.0.0">https://www.bilibili.com/video/BV1Hi4y1o7Mo?spm_id_from=333.999.0.0</a></p><ul><li><a href="https://space.bilibili.com/701523749/channel/seriesdetail?sid=747419&ctype=0">https://space.bilibili.com/701523749/channel/seriesdetail?sid=747419&ctype=0</a></li></ul></li><li><p>代数系统:https://www.bilibili.com/video/BV1da4y1W7BV?spm_id_from=333.337.search-card.all.click</p></li><li><p>ppt:https://mp.weixin.qq.com/s/UFa3V4hhQfeW4hO6JwhV7A</p></li></ul><hr><ul><li><p>质数又称素数。一个大于1的自然数，除了1和它自身外，不能被其他自然数整除的数叫做质数；否则称为合数（规定1既不是质数也不是合数）</p></li><li><p>整除:</p><ul><li><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20220326192836.png alt=20220326192836></li></ul></li></ul></div></div><div class=post-copyright><p class=copyright-item><span class=item-title>文章作者</span>
<span class=item-content>zput</span></p><p class=copyright-item><span class=item-title>上次更新</span>
<span class=item-content>0001-01-01</span></p></div><footer class=post-footer><nav class=post-nav><a class=prev href=/post/postgraduate/fundamental_math/><i class="iconfont icon-left"></i>
<span class="prev-text nav-default">基础数学</span>
<span class="prev-text nav-mobile">上一篇</span></a>
<a class=next href=/post/postgraduate/line/><span class="next-text nav-default">线性代数</span>
<span class="next-text nav-mobile">下一篇</span>
<i class="iconfont icon-right"></i></a></nav></footer></article></div><script src=https://giscus.app/client.js data-repo=zput/utterances-comments data-repo-id=R_kgDOHhATGQ data-category=Announcements data-category-id=DIC_kwDOHhATGc4CPxca data-mapping=pathname data-reactions-enabled=1 data-emit-metadata=1 data-input-position=top data-theme=light data-lang=zh-CN data-loading=lazy crossorigin=anonymous async></script></div></main><footer id=footer class=footer><div class=social-links><a href=mailto:wkzxc@sina.com class="iconfont icon-email" title=email></a>
<a href=https://github.com/zput class="iconfont icon-github" title=github></a>
<a href=http://zput.github.io/index.xml type=application/rss+xml class="iconfont icon-rss" title=rss></a></div><div class=copyright><span class=copyright-year>&copy;
2017 -
2022<span class=heart><i class="iconfont icon-heart"></i></span><span>zput</span></span></div></footer><div class=back-to-top id=back-to-top><i class="iconfont icon-up"></i></div></div><script src=https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin=anonymous></script>
<script src=https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin=anonymous></script>
<script src=https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin=anonymous></script>
<script type=text/javascript src=/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js></script>
<script type=text/javascript>window.MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]]}}</script><script async src=https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin=anonymous></script></body></html>