<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><title>编译原理-从下到上解析 - Zput's blog</title><meta name=renderer content="webkit"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta http-equiv=cache-control content="no-transform"><meta http-equiv=cache-control content="no-siteapp"><meta name=theme-color content="#f8f5ec"><meta name=msapplication-navbutton-color content="#f8f5ec"><meta name=apple-mobile-web-app-capable content="yes"><meta name=apple-mobile-web-app-status-bar-style content="#f8f5ec"><meta name=author content="zput"><meta name=description content="LR(0) 附录 形态和状态 形态 起始形态 已完成形态(可折叠形态[不是可折叠状态]) 形态的转移 延伸形态 形态集合 形态集合的闭合 状态 起始状态(记为I0) 形态集"><meta name=keywords content="Hugo,theme,even"><meta name=generator content="Hugo 0.118.2 with theme even"><link rel=canonical href=http://zput.github.io/post/_posts/%E4%BB%8E%E4%B8%8B%E5%BE%80%E4%B8%8Aparse/><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/manifest.json><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link href=/sass/main.min.e291ec317bf4a8f48812dc8bcd749ad9270976917bf2027d01a4415caecb80a5.css rel=stylesheet><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin=anonymous><meta property="og:title" content="编译原理-从下到上解析"><meta property="og:description" content="LR(0) 附录 形态和状态 形态 起始形态 已完成形态(可折叠形态[不是可折叠状态]) 形态的转移 延伸形态 形态集合 形态集合的闭合 状态 起始状态(记为I0) 形态集"><meta property="og:type" content="article"><meta property="og:url" content="http://zput.github.io/post/_posts/%E4%BB%8E%E4%B8%8B%E5%BE%80%E4%B8%8Aparse/"><meta property="article:section" content="post"><meta property="article:published_time" content="2019-03-26T08:47:11+01:00"><meta property="article:modified_time" content="2019-03-26T08:47:11+01:00"><meta itemprop=name content="编译原理-从下到上解析"><meta itemprop=description content="LR(0) 附录 形态和状态 形态 起始形态 已完成形态(可折叠形态[不是可折叠状态]) 形态的转移 延伸形态 形态集合 形态集合的闭合 状态 起始状态(记为I0) 形态集"><meta itemprop=datePublished content="2019-03-26T08:47:11+01:00"><meta itemprop=dateModified content="2019-03-26T08:47:11+01:00"><meta itemprop=wordCount content="4264"><meta itemprop=keywords content="编译原理,"><meta name=twitter:card content="summary"><meta name=twitter:title content="编译原理-从下到上解析"><meta name=twitter:description content="LR(0) 附录 形态和状态 形态 起始形态 已完成形态(可折叠形态[不是可折叠状态]) 形态的转移 延伸形态 形态集合 形态集合的闭合 状态 起始状态(记为I0) 形态集"><!--[if lte IE 9]><script src=https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js></script><![endif]--><!--[if lt IE 9]><script src=https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js></script>
<script src=https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js></script><![endif]--></head><body><div id=mobile-navbar class=mobile-navbar><div class=mobile-header-logo><a href=/ class=logo>Zput</a></div><div class=mobile-navbar-icon><span></span>
<span></span>
<span></span></div></div><nav id=mobile-menu class="mobile-menu slideout-menu"><ul class=mobile-menu-list><a href=/go-goroutine><li class=mobile-menu-item>go源码专栏</li></a><a href=/post/mrmk/><li class=mobile-menu-item>中间件专栏</li></a><a href=/post/cloud_native/><li class=mobile-menu-item>云原生专栏</li></a><a href=/post/postgraduate/><li class=mobile-menu-item>考研专栏</li></a><a href=/post/><li class=mobile-menu-item>时间线</li></a></ul></nav><div class=container id=mobile-panel><header id=header class=header><div class=logo-wrapper><a href=/ class=logo>Zput</a></div><nav class=site-navbar><ul id=menu class=menu><li class=menu-item><a class=menu-item-link href=/go-goroutine>go源码专栏</a></li><li class=menu-item><a class=menu-item-link href=/post/mrmk/>中间件专栏</a></li><li class=menu-item><a class=menu-item-link href=/post/cloud_native/>云原生专栏</a></li><li class=menu-item><a class=menu-item-link href=/post/postgraduate/>考研专栏</a></li><li class=menu-item><a class=menu-item-link href=/post/>时间线</a></li></ul></nav></header><main id=main class=main><div class=content-wrapper><div id=content class=content><article class=post><header class=post-header><h1 class=post-title>编译原理-从下到上解析</h1><div class=post-meta><span class=post-time>2019-03-26</span><div class=post-category><a href=/categories/systemandprotocol/>systemAndProtocol</a></div></div></header><div class=post-toc id=post-toc><h2 class=post-toc-title>文章目录</h2><div class="post-toc-content always-active"><nav id=TableOfContents><ul><li><ul><li><ul><li><a href=#lr0>LR(0)</a></li><li><a href=#附录>附录</a></li><li><a href=#形态和状态>形态和状态</a><ul><li><a href=#形态>形态</a><ul><li><a href=#起始形态>起始形态</a></li><li><a href=#已完成形态可折叠形态不是可折叠状态>已完成形态(可折叠形态[不是可折叠状态])</a></li><li><a href=#形态的转移>形态的转移</a></li><li><a href=#延伸形态>延伸形态</a></li><li><a href=#形态集合>形态集合</a></li><li><a href=#形态集合的闭合>形态集合的闭合</a></li></ul></li><li><a href=#状态>状态</a><ul><li><a href=#span-idjump1起始状态记为i0span><span id=jump1>起始状态(记为<code>I0</code>)</span></a></li><li><a href=#span-idjump2形态集合的闭合closure-of-a-configurating-setspan><span id=jump2>形态集合的闭合(closure of a configurating set)</span></a></li><li><a href=#可折叠状态>可折叠状态</a></li></ul></li></ul></li><li><a href=#span-idjump_not_end_sign非终结符和终结符span><span id=jump_not_end_sign>非终结符和终结符</span></a></li></ul></li></ul></li></ul></nav></div></div><div class=article-container><div class=post-content><ul><li><a href=#lr0>LR(0)</a></li><li><a href=#%E9%99%84%E5%BD%95>附录</a></li><li><a href=#%E5%BD%A2%E6%80%81%E5%92%8C%E7%8A%B6%E6%80%81>形态和状态</a><ul><li><a href=#%E5%BD%A2%E6%80%81>形态</a><ul><li><a href=#%E8%B5%B7%E5%A7%8B%E5%BD%A2%E6%80%81>起始形态</a></li><li><a href=#%E5%B7%B2%E5%AE%8C%E6%88%90%E5%BD%A2%E6%80%81%E5%8F%AF%E6%8A%98%E5%8F%A0%E5%BD%A2%E6%80%81%E4%B8%8D%E6%98%AF%E5%8F%AF%E6%8A%98%E5%8F%A0%E7%8A%B6%E6%80%81>已完成形态(可折叠形态[不是可折叠状态])</a></li><li><a href=#%E5%BD%A2%E6%80%81%E7%9A%84%E8%BD%AC%E7%A7%BB>形态的转移</a></li><li><a href=#%E5%BB%B6%E4%BC%B8%E5%BD%A2%E6%80%81>延伸形态</a></li><li><a href=#%E5%BD%A2%E6%80%81%E9%9B%86%E5%90%88>形态集合</a></li><li><a href=#%E5%BD%A2%E6%80%81%E9%9B%86%E5%90%88%E7%9A%84%E9%97%AD%E5%90%88>形态集合的闭合</a></li></ul></li><li><a href=#%E7%8A%B6%E6%80%81>状态</a><ul><li><a href=#span-idjump1%E8%B5%B7%E5%A7%8B%E7%8A%B6%E6%80%81%E8%AE%B0%E4%B8%BAi0span>起始状态(记为<code>I0</code>)</a></li><li><a href=#span-idjump2%E5%BD%A2%E6%80%81%E9%9B%86%E5%90%88%E7%9A%84%E9%97%AD%E5%90%88closure-of-a-configurating-setspan>形态集合的闭合(closure of a configurating set)</a></li><li><a href=#%E5%8F%AF%E6%8A%98%E5%8F%A0%E7%8A%B6%E6%80%81>可折叠状态</a></li></ul></li></ul></li><li><a href=#span-idjump_not_end_sign%E9%9D%9E%E7%BB%88%E7%BB%93%E7%AC%A6%E5%92%8C%E7%BB%88%E7%BB%93%E7%AC%A6span>非终结符和终结符</a></li></ul><h3 id=lr0>LR(0)</h3><p>下面用一个非常简单的例子来介绍如何使用形态和状态来构造 LR(0) 分析。语法为：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>S -&gt; A
</span></span><span class=line><span class=cl>A -&gt; aBd
</span></span><span class=line><span class=cl>B -&gt; bc
</span></span></code></pre></td></tr></table></div></div><p>首先，求出该语法的<a href=#jump1>起始状态 I0</a></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>I0:
</span></span><span class=line><span class=cl>    S -&gt; .A
</span></span><span class=line><span class=cl>    A -&gt; .aBd
</span></span></code></pre></td></tr></table></div></div><p>对语法中的所有符号<code>X(S, A, B, a, b, c, d)</code>, 求出<code>I0</code>遇到<code>X</code>的后继状态<code>NEXT(I0, X)</code>, 若<code>NEXT(I0, X)</code>不是空集, 则将其添加到状态转移图中，如下：</p><p><img src=https://raw.githubusercontent.com/zput/myPicLib/master/blog_pic/44db9d56-5ca1-6a2c-c1e2-e29d337d8cbd.png alt>
图11.2 状态转移图1</p><p>按以上方法，不断的生成新的状态，直到不再出现新的状态，最终如下：</p><p><img src=https://raw.githubusercontent.com/zput/myPicLib/master/blog_pic/dc665bcb-70b1-7458-ac80-81ccf489a8e9.png alt>
图11.3 状态转移图2</p><blockquote><p>显然，解析的最开始的时候，没有读入任何符号，此时的状态为<code>I0</code>，每读入一个符号，则转移到另一个状态.</p></blockquote><p>这个状态转移图似乎和有限状态自动机的运行图很相似，那么，解析的过程是不是就是用有限状态自动机来依照上面那个图来运行一遍？答案是不行的。上一章已经说过了，有限状态自动机只能解析正则语言，无法解析复杂的上下文无关语言。为了解析上下文无关语法，我们需要一种更强大的自动机，这种自动机不仅仅需要记住它当前的状态，还需要记住它的历史路径，记住它是如何到达当前状态的。</p><blockquote><p>简单来说，这种自动机含有一个栈，它的大致的运行机制为：</p><blockquote><p>在读入符号之前，将初始状态<code>I0</code>压入栈顶，之后，每读入一个符号，它就转移到下一个状态（将下一个状态压入栈顶），当它转移到<a href=3>一个可折叠状态</a>时，它执行一个折叠动作（将前面的一些状态出栈、再压入下一个状态），一直到它折叠得到的非终结符是起始符号，且下一个符号是 $ 时，它才终止运行。</p></blockquote></blockquote><p>上面这段描述只是一个大致的运行流程，里面有两个重要的问题没讲清楚，一个是<strong>转移</strong>和<strong>折叠</strong>动作的具体操作步骤，另一个什么是可折叠状态.</p><p>我们先把后一个问题讲清楚：
可折叠状态(reduceable state):只含有一个形态的状态，且此形态为可折叠形态，如图11.3中的<code>I1, I5和I6</code>.</p><h3 id=附录>附录</h3><h3 id=形态和状态>形态和状态</h3><p>LR(0) 分析法是一种最基本的 LR 分析法，其构造过程中的核心是<strong>状态 和 形态</strong>, 以下给出相关术语的正式定义，并介绍如何构造 LR(0) 分析器.</p><h4 id=形态>形态</h4><p>形态（configuration）:一个产生式的解析程度，用一个产生式加一个位置黑点来表示，例如，产生式 A -> XYZ 有 4 中可能的解析程度:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>A –&gt; •XYZ
</span></span><span class=line><span class=cl>A –&gt; X•YZ
</span></span><span class=line><span class=cl>A –&gt; XY•Z
</span></span><span class=line><span class=cl>A –&gt; XYZ•
</span></span></code></pre></td></tr></table></div></div><p>位置黑点表示本产生式解析过程中前进到的位置，比如一个产生式: S -> abc ，则它最开始的形态为 S -> •abc ，读入一个 a 后其形态变为 S -> a•bc ，再读入一个 b 后变为 S -> ab•c 。</p><blockquote><p>形态一般用大写字母 C 表示。</p></blockquote><p>需要注意的是，如果一个产生式的右边是空串，如 A -> ε ，那么形态 A -> •ε 和 A -> ε• 是同样的形态，一般都只采用后一种表示方式。</p><h5 id=起始形态>起始形态</h5><blockquote><blockquote><p>产生式的<strong>起始形态（start configuration of a production）</strong>:位置黑点位于该产生式右边的第一个符号的前面的形态，如： A –> •XYZ.</p></blockquote></blockquote><h5 id=已完成形态可折叠形态不是可折叠状态>已完成形态(可折叠形态[不是可折叠状态])</h5><blockquote><blockquote><p>产生式的<strong>已完成形态（complete configuration of a production）</strong>:位置黑点位于该产生式右边的最后一个符号的后面的形态，如： A –> XYZ• 。也称为<strong>可折叠形态（reduceable configuration）</strong>.</p></blockquote></blockquote><h5 id=形态的转移>形态的转移</h5><blockquote><blockquote><p>形态的转移 ： 当一个形态 A –> X•YZ 遇到一个符号 Y 时，它就转移到下个形态： A –> XY•Z ，见下图：
<img src=https://raw.githubusercontent.com/zput/myPicLib/master/blog_pic/b22f5e5f-06be-439f-aa18-9827aef3ca38.png alt>
图11.1 形态转移示意图</p></blockquote></blockquote><p>若记 C = [A -> X•YZ] ， C’ = [A –> XY•Z] ，称形态 C’ 为形态 C 遇到符号 Y 时的 后继形态（successor configuration） ，可写为 NEXT(C, Y) 。若形态 C 遇到的符号 X 不等于其位置黑点后面的符号时，称 NEXT(C, X) 不存在。</p><h5 id=延伸形态>延伸形态</h5><blockquote><blockquote><p>延伸形态（extended configuration） ：对于形态 A –> v•Yw ，若 Y 为<a href=#jump_not_end_sign>非终结符</a>，且 Y -> u ，则形态 Y -> •u 是形态 A –> v•Yw 的延伸形态，进一步的，若 u 的第一个符号为非终结符 Z ，且 Z -> u1 ，则形态 Z -> •u1 既是 Y -> •u 的延伸形态，也是 A –> v•Yw 的延伸形态。</p></blockquote></blockquote><p>例如，语法：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>S -&gt; Ab
</span></span><span class=line><span class=cl>A -&gt; Bc
</span></span><span class=line><span class=cl>B -&gt; d
</span></span></code></pre></td></tr></table></div></div><blockquote><blockquote><p><code>A -> •Bc</code> 和 <code>B -> •d</code> 都是 <code>S -> •AB</code> 的延伸形态。</p></blockquote></blockquote><p>这里要注意的是： 延伸的方向是单向的 ，上面这个语法中，A -> •Bc 是 S -> •AB 的延伸形态，但 S -> •AB 不是 A -> •Bc 的延伸形态，只有 B -> •d 才是 A -> •Bc 的延伸形态。</p><h5 id=形态集合>形态集合</h5><blockquote><blockquote><p>形态集合（configurating set） ： 一个由有限个形态组成的集合.</p></blockquote></blockquote><h5 id=形态集合的闭合>形态集合的闭合</h5><blockquote><blockquote><p><strong>形态集合的闭合（closure of a configurating set）</strong> ： 形态集合的闭合就是把<strong>这个集合里</strong>所有形态的<strong>所有延伸形态</strong>全部添加进这个集合。按以下步骤进行（设该集合名为 I ）：</p><blockquote><ol><li>遍历 I ，对 I 中的每一条形态<code>A -> u • v</code> ，若 v 的第一个符号为非终结符 B ，则将其所有的产生式的起始形态添加进 S ，即若<code>B -> u1 | u2 | ... | un</code>, 则将 <code>B -> • u1, B -> • u2, ..., B -> • un</code>添加进<code>I</code>.</li><li>重复（1），直到不再出现新的形态。</li></ol></blockquote></blockquote></blockquote><p>闭合操作的得到的新集合 I’ 称为原集合 I 的 闭包集合 ，记为 CLOSURE(I) 。</p><h4 id=状态>状态</h4><blockquote><blockquote><p>状态(state):进行过闭合操作的形态集合，一般用大写字母I表示，也就是说，若形态<strong>C</strong>属于状态<strong>I</strong> ，则<strong>C</strong>的延伸形态也属于<strong>I</strong>.</p></blockquote></blockquote><h5 id=span-idjump1起始状态记为i0span><span id=jump1>起始状态(记为<code>I0</code>)</span></h5><p>上下文无关语法的起始状态（start state of a CFG） ： 若一个 CFG 的起始符号 S 的所有产生式为 <code>S -> u1 | u2 | ... | un</code> ，且 S 不位于任何产生式的右边，则其起始状态(记为I0)是这些产生式的起始形态的集合的<a href=#jump2>闭包集合</a>，即：<code>I0 = CLOSURE( { [S-> • u1], [S-> • u2], ... [S-> • un] } )</code></p><p>例如，语法：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>S -&gt; A
</span></span><span class=line><span class=cl>A -&gt; aBd
</span></span><span class=line><span class=cl>B -&gt; bc
</span></span></code></pre></td></tr></table></div></div><p>it的起始状态:</p><ul><li>I0 = CLOSURE( {[S-> • A]} )<ul><li>CLOSURE( {[S-> • A]} ) ==> S-> .aBd ==> a是终结符.</li></ul></li><li>I0 = { [S-> • A], [A-> • aBd] }</li></ul><blockquote><p>为什么没有[B -> bc]?</p></blockquote><p>起始状态可以认为是<strong>语法解析的初始状态</strong>，此时尚未读入任何符号，因此<strong>起始符号</strong>的所有产生式都处在其初始形态。</p><p>上面提到了，要求 S 不位于任何产生式的右边。如果 S 位于某条产生式的右边，则这个状态可能不能代表语法解析的初始状态。例如，对于语法： S -> a | aS 。当解析句子 aaa 的时候，状态{ [S-> • a], [S-> • aS] }，可能代表 ” • aaa” 的状态，也可能代表 “a • aa” 的状态 （这里的 ” • ” 表示已读入符号和未读入符号的分割位置）。</p><p>为了保证起始符号不位于任何产生式的右边，一般在语法中增加一个非终结符 S’ 和一条产生式 S’ -> S ，而用这个 S’ 作为起始符号。如前面这个语法 S -> a | aS 可以改为：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>S&#39; -&gt; S
</span></span><span class=line><span class=cl>S  -&gt; a
</span></span><span class=line><span class=cl>S  -&gt; aS
</span></span></code></pre></td></tr></table></div></div><p>此时的状态<code>{ [S’-> • S], [S-> • a], [S-> • aS] }</code>就只能代表<code>” • aaa”</code>的状态了.</p><h5 id=span-idjump2形态集合的闭合closure-of-a-configurating-setspan><span id=jump2>形态集合的闭合(closure of a configurating set)</span></h5><blockquote><p>形态集合的闭合（closure of a configurating set） ： 形态集合的闭合就是把这个集合里所有形态的所有延伸形态全部添加进这个集合。按以下步骤进行（设该集合名为 I ）：</p><blockquote><ul><li>遍历 I ，对 I 中的每一条形态 A -> u • v ，若 v 的第一个符号为非终结符 B ，则将其所有的产生式的起始形态添加进 S ，即若 B -> u1 | u2 | &mldr; | un ，则将 B -> • u1, B -> • u2, &mldr;, B -> • un 添加进 I 。</li><li>重复（1），直到不再出现新的形态。</li></ul></blockquote></blockquote><p>起始状态起始状态
闭合操作的得到的新集合 I’ 称为原集合 I 的 闭包集合 ，记为 CLOSURE(I) 。</p><h5 id=可折叠状态>可折叠状态</h5><blockquote><blockquote><p><code>可折叠状态（reduceable state）</code>:只含有一个形态的状态，且此<strong>形态为可折叠形态(不是状态)</strong>，如图11.3中的 I1 、 I5 和 I6.</p></blockquote></blockquote><blockquote><blockquote><blockquote><p>形态（configuration）:一个产生式的解析程度，用一个产生式加一个位置黑点来表示</p><blockquote><p>一个产生式===>plus .===>形态
形态集合===>闭合操作===>状态</p><blockquote><ul><li>reference:形态集合, 形态集合的闭合.</li><li>状态(state):进行过闭合操作的形态集合，一般用大写字母I表示，也就是说，若形态<strong>C</strong>属于状态<strong>I</strong> ，则<strong>C</strong>的延伸形态也属于<strong>I</strong>.</li></ul></blockquote></blockquote></blockquote></blockquote></blockquote><p>自动机的具体操作流程为：</p><ul><li>（1） 将初始状态 I0 压入栈顶；</li><li>（2） 读入下一个符号 x ，相当于调用一次 x = yylex() ，有两种情况：<ul><li>（2.1） x 不是终结符：输入不合语法，执行 deny 操作，终止解析；</li><li>（2.2） x 是终结符：转到（3）；</li></ul></li><li>（3） 置 X = x ；</li><li>（4） 设栈顶状态为 I ，有以下两种情况：<ul><li>（4.1） I 不是可折叠状态，有以下三种情况：<ul><li>（4.1.1） NEXT(I, X) 存在（设为 I’）、 X 为终结符：执行 shift I’ 操作，将 I’ 压入栈顶，转到（2）；</li><li>（4.1.2） NEXT(I, X) 存在（设为 I’）、 X 为非终结符：执行 goto I’ 操作，将 I’ 压入栈顶，转到（3）；</li><li>（4.1.3） NEXT(I, X) 不存在：输入不合语法，执行 deny 操作，终止解析；</li></ul></li><li>（4.2） I 是可折叠状态，设 I 里面的形态对应的产生式为 A -> X1 X2 &mldr; Xn ，有以下三种情况：<ul><li>（4.2.1） A != S ：执行 reduce (A, n) 操作，将栈顶及以下 n 个状态出栈，置 X = A ，转到（4）；</li><li>（4.2.2） A == S 、 X != $ ：输入不合语法，执行 deny 操作，终止解析；</li><li>（4.2.3） A == S 、 X == $ ：输入合法，执行 accept 操作，终止解析。</li></ul></li></ul></li></ul><blockquote><p>上面这个语法中的每一行形如 “语句 -> 主语 谓语 宾语” 的式子称为 产生式（production）。</p><blockquote><ul><li>产生式左侧的符号（语句、主语、谓语和宾语）称为 非终结符（nonterminal） ，代表可以继续扩展或产生的符号，也就是说，当在某条产生式的右边遇到了此非终结符的时候，总是可以用本产生式的右边来替换这个非终结符。</li><li>而 “我、你、他、吃、饭、菜” 这些符号是 X 语言中的词，无法再产生新的符号了，称为 终结符（terminal） 。<strong>终结符只能出现在产生式的右边，非终结符则左边和右边都可以出现。</strong></li><li>上述产生式中有一个特别的非终结符： “语句” ， X 语言中的所有句子都以它为起点产生，这个符号被称为 起始符号（start symbol）。</li></ul></blockquote></blockquote><h3 id=span-idjump_not_end_sign非终结符和终结符span><span id=jump_not_end_sign>非终结符和终结符</span></h3><blockquote><ul><li>终结符:通俗的说就是不能单独出现在推导式左边的符号，也就是说终结符不能再进行推导.</li></ul><blockquote><p>详细一点说：终结符是一个形式语言的基本符号。就是说，它们能在一个形式语法的推导规则的输入或输出字符串存在，而且它们不能被分解成更小的单位。确切地说，一个语法的规则不能改变终结符。例如说，下面的语法有两个规则：
x -> xa
x -> ax
在这种语法之中，a是一个终结符，因为没有规则可以把a变成别的符号。不过，有两个规则可以把x变成别的符号，所以x是非终结符。一个形式语法所推导的形式语言必须完全由终结符构成。</p></blockquote></blockquote><blockquote><ul><li>非终结符： 不是终结符的都是非终结符。非终结符可理解为一个可拆分元素，而终结符是不可拆分的最小元素。</li></ul><blockquote><p>非终结符是可以被取代的符号。一个形式文法中必须有一个起始符号；这个起始符号属于非终结符的集合。</p></blockquote></blockquote><ul><li>判断注意:<ul><li>只要存在有 S→L ，则 S 必然是个非终结符</li><li>逗号，[，]，（，） 这5个都是终结符</li><li>一般书上把非终结符用大写字母 表示，而终结符用小写字母表示。</li></ul></li></ul></div></div><div class=post-copyright><p class=copyright-item><span class=item-title>文章作者</span>
<span class=item-content>zput</span></p><p class=copyright-item><span class=item-title>上次更新</span>
<span class=item-content>2019-03-26</span></p></div><footer class=post-footer><div class=post-tags><a href=/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/>编译原理</a></div><nav class=post-nav><a class=prev href=/post/_posts/%E6%A6%82%E5%BF%B5%E5%8E%9F%E7%90%86%E7%9A%84%E6%80%9D%E8%80%83/synchronous_asynchronous/><i class="iconfont icon-left"></i>
<span class="prev-text nav-default">异步与同步</span>
<span class="prev-text nav-mobile">上一篇</span></a>
<a class=next href=/post/_posts/tool/https/><span class="next-text nav-default">Https = http + ssl</span>
<span class="next-text nav-mobile">下一篇</span>
<i class="iconfont icon-right"></i></a></nav></footer></article></div><script src=https://giscus.app/client.js data-repo=zput/utterances-comments data-repo-id=R_kgDOHhATGQ data-category=Announcements data-category-id=DIC_kwDOHhATGc4CPxca data-mapping=pathname data-reactions-enabled=1 data-emit-metadata=1 data-input-position=top data-theme=light data-lang=zh-CN data-loading=lazy crossorigin=anonymous async></script></div></main><footer id=footer class=footer><div class=social-links><a href=mailto:wkzxc@sina.com class="iconfont icon-email" title=email></a>
<a href=https://github.com/zput class="iconfont icon-github" title=github></a>
<a href=http://zput.github.io/index.xml type=application/rss+xml class="iconfont icon-rss" title=rss></a></div><div class=copyright><span class=copyright-year>&copy;
2017 -
2023<span class=heart><i class="iconfont icon-heart"></i></span><span>zput</span></span></div></footer><div class=back-to-top id=back-to-top><i class="iconfont icon-up"></i></div></div><script src=https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin=anonymous></script>
<script src=https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin=anonymous></script>
<script src=https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin=anonymous></script>
<script type=text/javascript src=/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js></script>
<script type=text/javascript>window.MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]]}}</script><script async src=https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin=anonymous></script></body></html>