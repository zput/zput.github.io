<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><title>编程范式 - Zput's blog</title><meta name=renderer content="webkit"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta http-equiv=cache-control content="no-transform"><meta http-equiv=cache-control content="no-siteapp"><meta name=theme-color content="#f8f5ec"><meta name=msapplication-navbutton-color content="#f8f5ec"><meta name=apple-mobile-web-app-capable content="yes"><meta name=apple-mobile-web-app-status-bar-style content="#f8f5ec"><meta name=author content="zput"><meta name=description content="编程范式"><meta name=keywords content="Hugo,theme,even"><meta name=generator content="Hugo 0.110.0 with theme even"><link rel=canonical href=http://zput.github.io/post/_posts/%E8%8C%83%E5%BC%8F/%E8%8C%83%E5%BC%8F/><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/manifest.json><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link href=/sass/main.min.fdb1035139209ff03fa34c28400ff54f04900828b7cafe0d2cfb1f48b70a2ffd.css rel=stylesheet><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin=anonymous><meta property="og:title" content="编程范式"><meta property="og:description" content="编程范式"><meta property="og:type" content="article"><meta property="og:url" content="http://zput.github.io/post/_posts/%E8%8C%83%E5%BC%8F/%E8%8C%83%E5%BC%8F/"><meta property="article:section" content="post"><meta property="article:published_time" content="2020-10-20T15:00:00+00:00"><meta property="article:modified_time" content="2020-10-20T15:00:00+00:00"><meta itemprop=name content="编程范式"><meta itemprop=description content="编程范式"><meta itemprop=datePublished content="2020-10-20T15:00:00+00:00"><meta itemprop=dateModified content="2020-10-20T15:00:00+00:00"><meta itemprop=wordCount content="3405"><meta itemprop=keywords content="范式,"><meta name=twitter:card content="summary"><meta name=twitter:title content="编程范式"><meta name=twitter:description content="编程范式"><!--[if lte IE 9]><script src=https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js></script><![endif]--><!--[if lt IE 9]><script src=https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js></script>
<script src=https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js></script><![endif]--></head><body><div id=mobile-navbar class=mobile-navbar><div class=mobile-header-logo><a href=/ class=logo>Zput</a></div><div class=mobile-navbar-icon><span></span>
<span></span>
<span></span></div></div><nav id=mobile-menu class="mobile-menu slideout-menu"><ul class=mobile-menu-list><a href=/go-goroutine><li class=mobile-menu-item>go源码专栏</li></a><a href=/post/mrmk/><li class=mobile-menu-item>中间件专栏</li></a><a href=/post/cloud_native/><li class=mobile-menu-item>云原生专栏</li></a><a href=/post/postgraduate/><li class=mobile-menu-item>考研专栏</li></a><a href=/post/><li class=mobile-menu-item>时间线</li></a></ul></nav><div class=container id=mobile-panel><header id=header class=header><div class=logo-wrapper><a href=/ class=logo>Zput</a></div><nav class=site-navbar><ul id=menu class=menu><li class=menu-item><a class=menu-item-link href=/go-goroutine>go源码专栏</a></li><li class=menu-item><a class=menu-item-link href=/post/mrmk/>中间件专栏</a></li><li class=menu-item><a class=menu-item-link href=/post/cloud_native/>云原生专栏</a></li><li class=menu-item><a class=menu-item-link href=/post/postgraduate/>考研专栏</a></li><li class=menu-item><a class=menu-item-link href=/post/>时间线</a></li></ul></nav></header><main id=main class=main><div class=content-wrapper><div id=content class=content><article class=post><header class=post-header><h1 class=post-title>编程范式</h1><div class=post-meta><span class=post-time>2020-10-20</span><div class=post-category><a href=/categories/%E8%8C%83%E5%BC%8F/>范式</a></div></div></header><div class=post-toc id=post-toc><h2 class=post-toc-title>文章目录</h2><div class="post-toc-content always-active"><nav id=TableOfContents><ul><li><a href=#编程范式>编程范式</a><ul><li><a href=#非结构化编程>非结构化编程</a></li><li><a href=#结构化编程>结构化编程</a><ul><li><a href=#面向过程>面向过程</a></li><li><a href=#面向对象>面向对象</a></li><li><a href=#面向过程与面向对象>面向过程与面向对象</a></li><li><a href=#函数式编程>函数式编程</a></li></ul></li><li><a href=#总结>总结</a></li><li><a href=#附录>附录</a></li></ul></li></ul></nav></div></div><div class=article-container><div class=post-content><h1 id=编程范式>编程范式</h1><blockquote><p>Programming paradigms are a way to classify programming languages based on their features. Languages can be classified into multiple paradigms.
——From Wikipedia</p></blockquote><blockquote><p>编程范型、编程范式或程序设计法，是指软件工程中的一类典型的编程风格。
编程范型提供并决定了程序员对程序执行的看法。</p></blockquote><p>我们常常听到这些编程范式：泛型编程、结构化编程、面向过程编程、面向对象编程、函数式编程。
他们各有特点，但是他们的特点又不是独有的，所以有时候会很困惑，比如面向过程编程为自顶向下，将系统分为若干个模块，而模块中只允许出现顺序、选择和循环三种流程结构的语句；但是这些特点在面向对象编程中也会出现。这就使得我们常常很困惑，到底什么时候应该面向过程式的编程，什么时候面向对象式编程？如果你向有经验的程序员请教，或者上网搜索，有可能得到一种"面向实际问题编程"，即具体问题具体分析，依照个人经验来进行选择，虽然这样可以暂时避免理论上的困扰，但根据个人经验，可能你的经验难以描述，更多的是一种直觉，如果面对大项目时，没有能力做出决断。</p><p>下面我将根据编程范式发展不同发展阶段来一一看一下。</p><p align=middle><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20230128195228.png width=70% height=70% alt=UML></p><h2 id=非结构化编程>非结构化编程</h2><blockquote><p>Non-structured programming is the historically earliest programming paradigm capable of creating Turing-complete algorithms[citation needed]. in particular with the use of unstructured control flow using goto statements or equivalent.
——From Wikipedia</p></blockquote><p>非结构化编程是相对于结构化编程来说的，结构化指的是可级级分解并自治。</p><ul><li>特点：<ul><li>一个使用非结构化语言的程序经常包含按顺序排列的命令或声明，通常每个都占用一行。每一行都有编号或者标签，这样程序中的任意行都可以被执行。</li><li>非结构化程序设计引入了基本控制流的概念，比如循环、分支和跳转。尽管在非结构化模式中不存在过程，不过子程序还是可以使用的。和过程不同，子程序可能有多个入口和出口。子程序中是允许直接跳转入或跳转出的。这种灵活性可以实现协同程序，而这在过程化程序设计中是相当困难以至于不可能的。</li><li>非结构化程序设计中是没有本地变量的概念的。
我们最熟悉就是汇编语言，可以goto到任意代码处。</li></ul></li></ul><h2 id=结构化编程>结构化编程</h2><blockquote><p>Structured programming is a programming paradigm aimed at improving the clarity, quality, and development time of a computer program by making extensive use of the structured control flow constructs of selection (if/then/else) and repetition (while and for), block structures, and subroutines.
——From Wikipedia</p></blockquote><p>结构化编程（英语：Structured programming），一种编程典范。它采用子程序、块结构、for循环以及while循环等结构，来取代传统的 goto。希望借此来改善计算机程序的明晰性、质量以及开发时间，并且避免写出面条式代码。</p><p>可以看到面向过程与面向对象都有上述所说的特点。</p><h3 id=面向过程>面向过程</h3><blockquote><p>Procedural programming is a programming paradigm, derived from imperative programming,[1] based on the concept of the procedure call. Procedures (a type of routine or subroutine) simply contain a series of computational steps to be carried out. Any given procedure might be called at any point during a program&rsquo;s execution, including by other procedures or itself.
——From Wikipedia</p></blockquote><h3 id=面向对象>面向对象</h3><blockquote><p>Object-oriented programming (OOP) is a programming paradigm based on the concept of &ldquo;objects&rdquo;, which can contain data and code. The data is in the form of fields (often known as attributes or properties), and the code is in the form of procedures (often known as methods).
——From Wikipedia</p></blockquote><ul><li><p>核心特点：</p><ul><li>封装</li><li>继承</li><li>多态</li></ul></li><li><p>设计原则:</p><ul><li>单一职责原则(Single Responsibility Principle)</li><li>开闭原则(Open-closed Principle)</li><li>里氏替换原则 (The Liskov Substitution Principle)</li><li>接口隔离原则 (Interface Segregation Principle)</li><li>依赖倒置原则 (Dependence Inversion Principle)</li></ul></li></ul><h3 id=面向过程与面向对象>面向过程与面向对象</h3><p>面向过程与面向对象不是并列的关系。因为“对象”的每个方法内部局部，都是“过程”组成的，“过程”其实是“对象”的一部分。只不过，当出现两个以上主体（同时存在两个以上流程思路）时，“面向过程”就开始不清晰了，因为它在混合多个过程。换句话说，“面向对象编程”的每个主体内部、方法局部，依然是“面向过程”的，只是把属于别人的过程交给别人，自己只做自己故事的主角。因此，当我们说“面向过程编程”时，其实指的是“只有一个（隐藏于一切过程背后的）全局对象”或“有很多（属于本应提取却没有提取的对象的）过程混在一起运行”。因此，此二者之间如何取舍也变得清晰了：当没有必要“面向对象”时，就“面向过程”，此时的“面向过程”并不是“面向对象”的对立面，而是“面向对象”的一种极端的特例，它是一种主动的选择；当有必要“面向对象”时，就“面向对象”，如果这时再“面向过程”，它就没有资格称为一种范式，而只能视作“面向对象”尚未孕育而生时的一种原始状态。</p><p>我们再看“面向对象编程”的那些所谓的“核心特征”，就非常轻松了。以“继承”为例，它只是一种手段，本质上是“过程自治”原则的一种更精细的切分，它根本不（一定）是对现实事物的直接模拟。比如从概念上，似乎应当是“正方形”继承了“长方形”，所谓“正方形”只是“长方形”长宽一致时的一种特例；但实际上，从“功能自治之组合”的角度看，反而需要“长方形”继承“正方形”——因为“长方形”也可以像“正方形”一样具有同时设置宽高的能力，但“正方形”却不能具有“长方形”分别设置宽高的能力。正因为这种颠倒，“继承”（或者严格地讲“单继承”）是很难充分达到“面向对象编程”的核心目的的，只支持“单继承”的编程语言，一定会在其“面向对象”浪潮发展到一定的复杂度阶段时，因为难以贴合最终的工程场景诉求，而产生逆向溃败的现象，简称“函数式的反攻”。要充分发挥“面向对象”的潜力，必须要通过“多继承”的形式（打个比方，Fragment继承了Children、SelfClosingElement继承了Attributes，而OpenCloseElement同时继承了Children和Attributes，如果是单继承会非常难受；如果这个比方还不够，那么“彩色长方形积木”到底该继承“彩色”、“长方形”还是“积木”呢？“彩色进口家具”又该如何呢？），或者这时候“继承”这个词已经显得很奇怪了，“组合”这个词已经呼之欲出。也因此，绝对不应该有“面向组合编程”这种词产生，或者说绝不能让它与“面向对象编程”并列——因为“继承”只是“面向对象”的一种实现方式，它不是唯一的，甚至不是足够好的。最多只能说，“基于组合/多继承”的“面向对象编程”，和“基于（单）继承”的“面向对象编程”。</p><h3 id=函数式编程>函数式编程</h3><blockquote><p>functional programming is a programming paradigm where programs are constructed by applying and composing functions. It is a declarative programming paradigm in which function definitions are trees of expressions that map values to other values, rather than a sequence of imperative statements which update the running state of the program.
——From Wikipedia</p></blockquote><blockquote><p>函数式编程是一种编程范式，它将计算视为对数学函数的评估，避免了状态和可变数据</p></blockquote><ul><li>函数式编程主要特点是：<ul><li>stateless：函数不维护任何状态。函数式编程的核心精神是 stateless，简而言之就是它不能存在状态，打个比方，你给我数据我处理完扔出来。里面的数据是不变的。</li><li>immutable：输入数据是不能动的，动了输入数据就有危险，所以要返回新的数据集。</li></ul></li></ul><p>所以不是用了函数就是函数式编程，哪怕函数是一等公民，也不等于就是函数式编程。函数式的本质是：无状态/不可变数据</p><h2 id=总结>总结</h2><p>他们的区别和联系是什么？</p><table><thead><tr><th>编程范式</th><th>\</th><th>\</th><th>\</th><th>\</th></tr></thead><tbody><tr><td>非结构化编程</td><td></td><td></td><td></td><td></td></tr><tr><td><strong>结构化编程</strong></td><td></td><td></td><td>单维/单主体/单态</td><td>多维/多主体/多态</td></tr><tr><td><strong>结构化编程</strong></td><td></td><td>命令式/数据可变</td><td>面向过程编程</td><td>面向对象编程</td></tr><tr><td><strong>结构化编程</strong></td><td></td><td>声明式/数据不可变</td><td>函数式编程</td><td>（彩蛋）</td></tr></tbody></table><p>从上面可以看到他们的分类，那么为什么要这么分类呢？</p><p>计算机运行在图灵机模型之上，而我们现实世界中面临问题，要如果转化为计算机可识别运行，最终得到答案，这之间存在鸿沟，而这个鸿沟也就是程序员的舞台。</p><p>在这里我们把现实世界中问题，认为是各个领域（Domain）的问题，比如通信，嵌入式，银行，保险，交通，社交，购物等。</p><p align=middle><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20230130225914.png width=30% height=30% alt=效果图></p><p>程序员把领域问题映射到某个编程范式之上，然后通过编程语言来实现。显然，编程范式到图灵机模型的转化都由编译器来完成；而把领域问题映射到某个编程范式上，就是程序员的责任。</p><p>对于非结构化编程，程序员站在直接使用指令的角度去思考，习惯按照自己的逻辑去写，指令之间可能共享数据，这其中最方便的写法就是需要用到哪块逻辑就 goto 过去执行一段代码，然后再 goto 到另外一个地方，基本没有约束。</p><p align=middle><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/FT.jpg width=70% height=70% alt=非结构化编程></p><p>对于面向过程编程，是对<strong>代码流程</strong>有限制，但是对于数据还是没有限制，面向过程编程，在全局声明的变量，都可以访问，在函数内声明的局部变量有限制（<strong>对于数据有一定的限制</strong>）。</p><p align=middle><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20230131194235.png width=70% height=70% alt=面向对象编程></p><p>面向过程编程由于<strong>数据访问性</strong>带来较高的耦合复杂度，局部可复用性及响应变化能力差。</p><p>软件规模的不断膨胀，人们希望可以更小粒度的对软件进行复用和裁剪，将全局数据拆开，并将数据与其紧密耦合的方法放在一个逻辑边界内，这个逻辑边界就是对象，对外隐藏其细节。</p><p>将领域问题又开始映射成实体及关系（<code>程序 = 实体 + 关系</code>），而不再是数据结构和算法（<code>程序 = 算法 + 数据结构</code>）了，这就是面向对象编程。
为了将领域问题高效简介的映射到实体及关系，出现了UML（Unified Model Language，统一建模语言）</p><p align=middle><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20230131202608.png width=70% height=70% alt=UML></p><p>所以面向对象进一步约束了<strong>数据访问性</strong>，影响了数据作用域。</p><h2 id=附录>附录</h2><p><a href=https://zh.wikipedia.org/wiki/%E7%BC%96%E7%A8%8B%E8%8C%83%E5%9E%8B>wiki-编程范型</a></p><p><a href=https://zhuanlan.zhihu.com/p/354528902>聊聊编程范式</a></p><p><a href=https://zhuanlan.zhihu.com/p/467982867>编程范式</a></p><p><a href=https://www.visual-paradigm.com/guide/uml-unified-modeling-language/overview-of-the-14-uml-diagram-types/>UML</a></p><p><a href=https://insights.thoughtworks.cn/what-is-solid-principle/>SOLID</a></p><p><a href=https://zhuanlan.zhihu.com/p/46830303>编程原则OOP，SOLID</a></p></div></div><div class=post-copyright><p class=copyright-item><span class=item-title>文章作者</span>
<span class=item-content>zput</span></p><p class=copyright-item><span class=item-title>上次更新</span>
<span class=item-content>2020-10-20</span></p></div><footer class=post-footer><div class=post-tags><a href=/tags/%E8%8C%83%E5%BC%8F/>范式</a></div><nav class=post-nav><a class=prev href=/post/_posts/%E6%A8%A1%E5%BC%8F/%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F/><i class="iconfont icon-left"></i>
<span class="prev-text nav-default">访问者模式</span>
<span class="prev-text nav-mobile">上一篇</span></a>
<a class=next href=/post/_posts/%E8%8C%83%E5%BC%8F/%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F_%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/><span class="next-text nav-default">编程范式-函数编程</span>
<span class="next-text nav-mobile">下一篇</span>
<i class="iconfont icon-right"></i></a></nav></footer></article></div><script src=https://giscus.app/client.js data-repo=zput/utterances-comments data-repo-id=R_kgDOHhATGQ data-category=Announcements data-category-id=DIC_kwDOHhATGc4CPxca data-mapping=pathname data-reactions-enabled=1 data-emit-metadata=1 data-input-position=top data-theme=light data-lang=zh-CN data-loading=lazy crossorigin=anonymous async></script></div></main><footer id=footer class=footer><div class=social-links><a href=mailto:wkzxc@sina.com class="iconfont icon-email" title=email></a>
<a href=https://github.com/zput class="iconfont icon-github" title=github></a>
<a href=http://zput.github.io/index.xml type=application/rss+xml class="iconfont icon-rss" title=rss></a></div><div class=copyright><span class=copyright-year>&copy;
2017 -
2023<span class=heart><i class="iconfont icon-heart"></i></span><span>zput</span></span></div></footer><div class=back-to-top id=back-to-top><i class="iconfont icon-up"></i></div></div><script src=https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin=anonymous></script>
<script src=https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin=anonymous></script>
<script src=https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin=anonymous></script>
<script type=text/javascript src=/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js></script>
<script type=text/javascript>window.MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]]}}</script><script async src=https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin=anonymous></script></body></html>